# 单例模式
单例模式就是一种“经典的，常用的，常考的” 设计模式

# 什么是设计模式
大佬对于一些常见的场景，给定了一个特定对应的解决方案，这个就是设计模式，这个是可以被推广使用的

# 单例模式的特定

某些类，只应该需要又一个对象（实例），就称为单例

例如：一个男人只能取一个老婆
> 类         对象
> 
> threadpool   tp
> 
> 定义一个对象：开辟空间+给空间写入初始值<u>（本质上就是将对象加载到内存里面）</u>
> 
> 只让该对象在内存中存在一份，加载一次

一般而言，我们的对象被设计称单例模式
> 1. 语意上，我们只需要一个
> 2. 该对象内部存在有大量的空间，保存了大量的数据，如果允许该对象存在多份的话，或者允许发生各自拷贝，内存中存在冗余数据
> 
> 这一般情况下，我们都可以设计成为单例模式


那么什么时候创建呢？
## 1. 饿汉模式
>吃完饭，立刻洗碗，因为这样，吃下一顿的时候立刻就能把饭拿到手里

**饿汉模式实现单例模式**

~~~cpp

template<class T>
class singleton{
    static T data;
    public:
    static T* getinstance()
    {
        return &data;
    }

}

~~~
只通过singleton这个包装类来使用T 对象，则一个进程中只有一个T 对象的实例

像这种静态成员，只要创建了一个对象这个静态成员立刻就开辟了，这就叫做饿汉模式

## 2. 懒汉模式
> 吃完饭，先把碗放下来，等到下一次要吃饭的时候再去洗这个碗

（延迟加载），在用的时候再加载，


> 写时拷贝（在用的时候，再拷贝），申请空间（不需要的时候就不用再做），优化服务器的启动速度

懒汉模式创建单例模式
~~~cpp
template<class T>

class singleton
{
    static T* inst;//创建了一个类型指针，这个静态成员变量要在外面初始化为nullptr
    public:
    static T*getinstance()//如果我们创建了一个类，当时很长时间都不调用这个，就不会创建
    {
        if(inst==NULL)
        {
            inst=new T();//发现为空，外面就创建，否则就直接返回，只创建一个对象
        }
        return inst;//以后每次使用就直接返回他的地址
    }
}

~~~


智能指针是线程安全的

# 常见的其他各种锁
* 悲观锁：在每次读取数据的时候，总担心数据会被其他线程给修改，所以会在取数据前提前加锁（外面现在使用的锁，都被认为是悲观锁）
* 乐观锁：在每次取数据的时候，总是乐观的认为数据不会被其他线程修改


# 读者写者问题